# TODO

[NOTES]

- All built-in methods must have the following signature:
  (obj args ns interp)
  where obj is the object the method is called on,
  args is a list of arguments passed to the method,
  ns is the namespace it is called in,
  and interp is the interpreter object being used.

--- CODE ORGANIZATION

- Sigh, since many objects are mutually recursive, we run into module
  problems. The best way is probably to just abandon them altogether
  and use a massive "load" wherever necessary. =/

  In this case, builtin/integer.scm uses interpreter.scm; in fact, all
  builtin proto modules do, because they need to look up protos and to
  do that they need to inspect the interpreter object/record. But,
  interpreter.scm needs to build a list of protos, so it imports
  builtin/integer.scm and friends. Much hilarity ensues. :(

  It's also completely unnecessary, because at load/import time, none
  of the modules use code that uses the other; this is deferred until
  runtime.

- The various functions for making built-in protos look much the same,
  we can probably write a factory function for this, or maybe a macro
  if necessary.

--- PARSER

- Empty statements should be allowed (i.e., a single dot).

--- TESTS

- We need a way to run all tests (and show results properly). See the
  Gauche manual.

--- OBJECTS

- The following idiom seems common:

  (let ((bns (interpreter-builtin-ns interp))
        (int-proto (namespace-get bns "Integer"))
        (obj (clone-object int-proto :data n)))

  We should probably add a helper function FIND-PROTO or something.
  The builtin protos have their own namespace, so they should be easy to find.

--- NEXT UP

- Some obvious things we're going to need before the REPL is even
  remotely useful:

  - symbols
  - lists
  - name lookup
